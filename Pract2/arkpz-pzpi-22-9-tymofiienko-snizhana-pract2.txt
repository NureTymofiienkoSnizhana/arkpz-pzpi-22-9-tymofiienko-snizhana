1
Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії
Звіт
З дисципліни «Аналіз та рефакторинг коду»
З практичної роботи №2
Виконала:
ст. гр. ПЗПІ-22-9 Тимофієнко С. О.
Перевірив:
ст. викл. ПІ Сокорчук І. П.
Харків 2024
2
2 МЕТОДИ РЕФАКТОРИНГУ КОДУ ПРОГРАМНОГО
ЗАБЕЗПЕЧЕННЯ
1.1. Мета
Навчитися основним методам рефакторингу коду на основі реальних
прикладів з власних програмних проєктів. Навчитися ідентифікувати
проблеми в коді та використовувати відповідні методи рефакторингу для
покращення його якості.
1.2. Рефакторинг
Рефакторинг — це контрольований процес покращення коду, без
написання нової функціональності. Результат рефакторингу — це чистий код
і простий дизайн:
- Чистий код проходить усі тести. Якщо програма проходить тільки 95%
тестів, значить десь у вас завівся брудний код. Якщо у вас взагалі немає тестів,
ви не проходите цей пункт автоматично.
- Чистий код очевидний для інших програмістів. І я не маю на увазі якісь
супер складні алгоритми. Погане іменування змінних, роздуті класи і методи -
все це розмиває очевидність коду.
- Чистий код не містить дублювання. Якщо доводиться змінювати
ділянку коду з дублюванням, потрібно буде не забути внести такі самі зміни і
в інших місцях, де код повторюється.
- Чистий код легше і дешевше підтримувати.
1.3. Відокремлення змінної(Extract Variable)
Проблема: У вас є складний для розуміння вираз.
void RenderBanner()
{
if ((platform.ToUpper().IndexOf("MAC") > -1) &&
 (browser.ToUpper().IndexOf("IE") > -1) &&
 wasInitialized() && resize > 0 )
 {
 // do something
 }
3
}
Рішення: Помістіть результат виразу або його частини в окремі змінні,
що пояснюють суть виразу.
void RenderBanner()
{
bool isMacOs = platform.ToUpper().IndexOf("MAC") > -1;
bool isIE = browser.ToUpper().IndexOf("IE") > -1;
bool wasResized = resize > 0;
if (isMacOs && isIE && wasInitialized() && wasResized)
{
 // do something
}
}
Причини рефакторингу:
Головна мотивація цього рефакторингу — зробити зрозумілішим
складний вираз, розбивши його на проміжні частини. Це може бути:
- Умова оператора if () або частини оператора ?: у C-подібних мовах.
- Довгий арифметичний вираз без проміжних результатів.
- Довге склеювання рядків.
Переваги:
- Покращує читабельність коду. Намагайтеся дати виділеним змінним
хороші назви, які точно відображатимуть суть виразу. Так ви зробите код
читабельним і зможете позбутися від зайвих коментарів. Наприклад,
customerTaxValue, cityUnemploymentRate, clientSalutationString і так далі.
1.4. Заміна алгоритму(Substitute Algorithm)
Проблема: Ви хочете замінити існуючий алгоритм іншим?
string FoundPerson(string[] people)
{
for (int i = 0; i < people.Length; i++)
{
if (people[i].Equals("Don"))
 {
return "Don";
4
 }
 if (people[i].Equals("John"))
 {
return "John";
 }
 if (people[i].Equals("Kent"))
 {
return "Kent";
 }
}
return String.Empty;
}
Рішення: Замініть тіло методу, що реалізує старий алгоритм, новим
алгоритмом.
string FoundPerson(string[] people)
{
List<string> candidates = new List<string>() {"Don", "John",
"Kent"};
for (int i = 0; i < people.Length; i++)
{
if (candidates.Contains(people[i]))
 {
 return people[i];
 }
}
return String.Empty;
}
Причини рефакторингу:
- Поетапний рефакторинг — не єдиний варіант поліпшити програму.
Іноді ви зустрічаєтеся з таким нагромадженням проблем в методі, що його
набагато простіше переписати наново. З іншого боку, ви могли знайти
алгоритм, який куди простіше та ефективніше за поточний. В цьому випадку
потрібно просто замінити старий алгоритм новим.
5
- З часом ваш алгоритм може бути включений в набір відомої бібліотеки
або фреймворка, і ви можете захотіти позбутися власної реалізації, щоби
полегшити собі підтримку програми.
- Вимоги до роботи програми можуть змінитися настільки сильно, що
старий алгоритм неможливо просто «допиляти» до відповідності їм.
1.5. Об’єднання фрагментів, що дублюються, в умовних операторах
Проблема: Однаковий фрагмент коду знаходиться в усіх гілках
умовного оператора.
if (IsSpecialDeal())
{
total = price * 0.95;
Send();
}
else
{
total = price * 0.98;
Send();
}
Рішення: Винесіть його за рамки оператора.
if (IsSpecialDeal())
{
total = price * 0.95;
}
else
{
total = price * 0.98;
}
Send();
Причини рефакторингу:
Дублюючий код знаходиться усередині усіх гілок умовного оператора.
Найчастіше це є результатом еволюції коду усередині гілок оператора,
особливо, якщо над кодом працювало декілька людей.
Переваги:
6
- Вбиває дублювання коду.
Порядок рефакторингу:
1. Якщо дублюючі ділянки знаходяться на початку гілок оператора,
винесіть їх перед умовним оператором.
2. Якщо такий код виконується в кінці гілок, помістить його після
умовного оператора.
3. Якщо дублюючий код розташований випадковим чином усередині
гілок, вам треба спробувати пересунути його в початок або в кінець гілки,
залежно від того, чи міняє він результат подальшого коду.
4. Дублюючий фрагмент коду більший за один рядок можна
спробувати відокремити в новий метод, якщо в цьому є сенс.
1.6. Рефакторинг власного коду
Код до рефакторингу:
private void Search(DataGridView dgw)
{
 dgw.Rows.Clear();
 if (selectedTable == "Motorcycles")
 {
 string searchQuery = $"SELECT Motorcycles.motorcycle_id" +
textBox_search.Text + "%'";

 SqlCommand com = new SqlCommand(searchQuery,
motostoreDB.getConnection());
 motostoreDB.openConnection();
 SqlDataReader read = com.ExecuteReader();
 while (read.Read())
 {
 ReadSingleRowMoto(dgw, read);
 }
 read.Close();
 }
 else if (selectedTable == "Orders")
 {
 string searchQuery = $"SELECT Orders.order_id" +
textBox_search.Text + "%'";

 SqlCommand com = new SqlCommand(searchQuery,
motostoreDB.getConnection());
 motostoreDB.openConnection();
 SqlDataReader read = com.ExecuteReader();
 while (read.Read())
 {
 ReadSingleRowOrders(dgw, read);
7
 }
 read.Close();
 }
}
Код після рефакторингу:
private void Search(DataGridView dgw)
{
 dgw.Rows.Clear();
 string searchQuery = "";
 if (selectedTable == "Motorcycles")
 {
 searchQuery = $"SELECT Motorcycles.motorcycle_id" +
textBox_search.Text + "%'";
 }
 else if (selectedTable == "Orders")
 {
 searchQuery = $"SELECT Orders.order_id" + textBox_search.Text +
"%'";
 }
 else if (selectedTable == "Customers")
 {
 searchQuery = $"SELECT Customers.cust_id" + textBox_search.Text
+ "%'";
 }
 else if (selectedTable == "Factories")
 {
 searchQuery = $"SELECT * FROM Factories " + textBox_search.Text
+ "%'";
 }
 SqlCommand com = new SqlCommand(searchQuery,
motostoreDB.getConnection());
 motostoreDB.openConnection();
 SqlDataReader read = com.ExecuteReader();
 while (read.Read())
 {
 ReadSingleRowMoto(dgw, read);
 }
 read.Close();
}
1.7. Висновок
Отже, рефакторинг є невід'ємною частиною процесу розробки якісного
програмного забезпечення. Він дозволяє поліпшувати структуру коду,
підвищувати його продуктивність та масштабованість, знижувати складність і
забезпечувати легшу підтримку й розвиток проектів у довгостроковій
перспективі. Використання методів рефакторингу допомагає підтримувати
код чистим і зрозумілим, що в свою чергу позитивно впливає на роботу
команди та кінцевий продукт.
8
1.8. Джерела
1) https://refactoring.guru/uk
2) https://brainlab.com.ua/uk/blog-uk/shho-take-refaktoryng-kodu-inavishho-vin-potribnyj
Посилання на репрозиторій:
https://github.com/NureTymofiienkoSnizhana/arkpz-pzpi-22-9-tymofiienkosnizhana
Посилання на відео-захист: https://youtu.be/1tvXPyHujAo
9
ДОДАТОК А
Рисунок А.1 – Перший слайд презентації
Рисунок А.2 – Вступ
10
Рисунок А.3 – Відокремлення змінної: проблема
Рисунок А.4 – Відокремлення змінної: рішення
11
Рисунок А.5 – Заміна алгоритму: проблема
Рисунок А.6 – Заміна алгоритму: рішення
12
Рисунок А.7 - Об’єднання фрагментів, що дублюються, в умовних
операторах: проблема
Рисунок А.7 - Об’єднання фрагментів, що дублюються, в умовних
операторах: рішення
13
Рисунок А.9 - Рефакторинг власного коду: проблема
Рисунок А.10 - Рефакторинг власного коду: рішення
14
Рисунок А.11 – Висновок
Рисунок А.12 – Джерела інформації